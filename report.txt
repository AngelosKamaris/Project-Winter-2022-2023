Τρέχουμε έναν κατάλογο με τα εξής αρχεία:

../instances/
uniform-0000010-1.instance
london-0000050.instance
uniform-0000100-1.instance
uniform-0000100-2.instance
uniform-0000200-2.instance
uniform-0000500-1.instance
uniform-0001000-1.instance
uniform-0001000-2.instance
uniform-0002000-1.instance
uniform-0005000-1.instance


Algorithm 1 --> incremental + local search
Size   || minscore | max score | min bound | max bound ||
10   || 0.351727 | 0.884275 | 0.351727 | 0.884275 || 
50   || 0.207241 | 0.807427 | 0.207241 | 0.807427 ||
100   || 0.548793 | 1.46705 | 0.275357 | 0.726846 || 
200   || 0.249888 | 0.702722 | 0.249888 | 0.702722 || 
500   || 0.288635 | 0.702228 | 0.288635 | 0.702228 || 
1000   || 0.53682 | 1.37563 | 0.279423 | 0.685494 || 
2000   || 0.275204 | 0.699194 | 0.275204 | 0.699194 || 
5000   || 0.264845 | 0.684318 | 0.264845 | 0.684318 ||

Παρατηρούμε ότι βρίσκονται λύσεις και δεν ξεπερνάει τον χρόνο του cut-off, αν και για σημεία > 500, 
ο αλγόριθμος αργεί. Ωστόσο, πράγματι υπάρχουν βελτιώσεις (από τον incremental στον local serach) και
αυτό φαίνεται από τα χαμηλά min scores (<0.4*n, όπου n ο αριθμός των αρχείων με το ίδιο πλήθος σημείων) 
και τα υψηλά max scores (>0.6*n).

Algorithm 2 --> incremental + local search + global step
Size   || minscore | max score | min bound | max bound ||
10   || 0.364775 | 0.897371 | 0.364775 | 0.897371 || 
50   || 0.310156 | 0.77065 | 0.310156 | 0.77065 ||
100   || 0.598101 | 1.39753 | 0.304012 | 0.69157 || 
200   || 0.266199 | 0.680509 | 0.266199 | 0.680509 || 
500   || 0.292332 | 0.695131 | 0.292332 | 0.695131 || 
1000   || 0.547737 | 1.3596 | 0.283253 | 0.674328 || 
2000   || 0.27058 | 0.698264 | 0.27058 | 0.698264 || 
5000   || 0.265266 | 0.6842 | 0.265266 | 0.6842 ||

Παρατηρούμε ότι πάλι βρίσκονται λύσεις και δεν ξεπερνάει τον χρόνο του cut-off, ωστόσο λόγο του
local search, ο αλγόριθμος αργεί. Δεν παρατηρούνται έντονες βελτιώσεις σε σχέση με τον αλγόριθμο 1,
που σημαίνει ότι ο global step κάποιες φορές βελτιώνει και κάποιες χειροτερεύει το αποτέλεσμα του 
local search. Αυτό οφείλεται στη συχνή χρήση rand() (βλ. εργασία 2).

*Δοκιμάσαμε παραλλαγή του αλγόριθμου με local step αντί για global step μετά το local search και 
παρατηρήσαμε παρόμοια συμπεριφορά, εξού και δεν συμπεριλάβαμε αυτον τον συνδυασμό. 

Algorithm 3 --> incremental + global step + local step
Size   || minscore | max score | min bound | max bound ||
10   || 1 | 0.496869 | 1 | 0.496869 || 
50   || 0.38891 | 0.712645 | 0.38891 | 0.712645 || 
100   || 0.603468 | 1.40294 | 0.308173 | 0.695058 || 
200   || 0.260875 | 0.684554 | 0.260875 | 0.684554 || 
500   || 0.297142 | 0.688647 | 0.297142 | 0.688647 || 
1000   || 0.553723 | 1.35277 | 0.287169 | 0.673266 || 
2000   || 0.279032 | 0.691986 | 0.279032 | 0.691986 || 
5000   || 0.266393 | 0.683473 | 0.266393 | 0.683473 || 

Παρατηρούμε ότι για 10 σημεία, ο αλγόριθμος αποτυγχάνει. Η αποτυχία οφείλεται στον global step, το οποίο
αδυνατεί να βρεί λύση (όχι στο cut-off). Τα max και min scores είναι ικανοποιητικά. Από πιο λεπτομερής παρατήρηση, 
βγάλαμε το συμπέρασμα ότι κάποιες φορές που ο global step βελτιώνει το αποτέλεσμα του incremental, 
ο local step μπορεί στη συνέχεια είτε να χειροτερεύσει το αποτέλεσμα είτε να το καλυτερεύσει, 
αλλά χωρίς να βελτιώνει σχεδόν ποτέ το αποτέλεσμα του incremental. 

Algorithm 4 --> subdivision(with convex hull) + local step
Size   || minscore | max score | min bound | max bound ||
10   || 0.172398 | 0.660593 | 0.172398 | 0.660593 ||
50   || 0.162236 | 0.667332 | 0.162236 | 0.667332 || 
100   || 0.643546 | 1.43473 | 0.322133 | 0.697797 || 
200   || 0.276651 | 0.784039 | 0.276651 | 0.784039 || 
500   || 0.290823 | 0.769689 | 0.290823 | 0.769689 || 
1000   || 0.585237 | 1.50036 | 0.302696 | 0.744796 || 
2000   || 0.295046 | 0.78555 | 0.295046 | 0.78555 || 
5000   || 0.300899 | 0.786227 | 0.300899 | 0.786227 ||

Algorithm 5 --> subdivision(with convex hull) + global step
Size   || minscore | max score | min bound | max bound ||
10   || 0.0176843 | 0 | 0.0176843 | 0 || 
50   || 0.256312 | 0.714726 | 0.256312 | 0.714726 || 
100   || 0.645517 | 1.44768 | 0.355842 | 0.722095 || 
200   || 0.289108 | 0.788114 | 0.289108 | 0.788114 || 
500   || 0.277975 | 0.771718 | 0.277975 | 0.771718 || 
1000   || 0.583596 | 1.50695 | 0.309225 | 0.749544 || 
2000   || 0.29348 | 0.786916 | 0.29348 | 0.786916 || 
5000   || 0.303939 | 0.787458 | 0.303939 | 0.787458 ||

Παρατηρούμε ότι τα αποτελέσματα στους 2 αλγόριθμους (4 και 5) είναι παρόμοια, με ίσως λίγο καλύτερα αυτά του global step.
Ωστόσο, παρατηρούμε ότι το global step (όπως και στον αλγόριθμο 3) κάποιες φορές αποτυγχάνει για λίγα σημεία, πχ 10. Ο 
subdivision από μόνος του, δίνει συνήθως μια καλή βελτίωση σε σχέση με καποια αρχικοποίηση, ωστόσο με local ή global step
επιπλεόν κάποιες φορές μπορεί να κάνει μια ακόμα μεγαλύτερη βελτίωση. Φυσικά επειδή σε κάθε περίπτωση η χρήση των rand
είναι συχνή και το κριτήριο metropolis αφήνει πολύ περιθώριο για χειροτερεύση, τα αποτελέσματα μπορεί να μην είναι πάντα
επιθυμητά.


Algorithm 6 --> subdivision(with convex hull) + global step + local step
Size   || minscore | max score | min bound | max bound ||
10   || 0.266412 | 0.0387143 | 0.266412 | 0.0387143 || 
50   || 0.284264 | 0.676436 | 0.284264 | 0.676436 ||
100   || 0.579428 | 1.53494 | 0.345839 | 0.721908 || 
200   || 0.307195 | 0.793874 | 0.307195 | 0.793874 || 
500   || 0.289318 | 0.759493 | 0.289318 | 0.759493 || 
1000   || 0.588733 | 1.49509 | 0.314556 | 0.744904 || 
2000   || 0.284006 | 0.791265 | 0.284006 | 0.791265 ||
5000   || 0.30287 | 0.785805 | 0.30287 | 0.785805 || 

Algorithm 7 --> subdivision(with convex hull) + local step + global step 
Size   || minscore | max score | min bound | max bound ||
10   || 0.00688254 | 0.326156 | 0.00688254 | 0.326156 || 
50   || 0.0487237 | 0.624892 | 0.0487237 | 0.624892 || 
100   || 0.615194 | 1.44764 | 0.318435 | 0.691886 || 
200   || 0.289564 | 0.789802 | 0.289564 | 0.789802 || 
500   || 0.287808 | 0.76489 | 0.287808 | 0.76489 || 
1000   || 0.592893 | 1.49704 | 0.313095 | 0.746957 || 
2000   || 0.281879 | 0.787475 | 0.281879 | 0.787475 || 
5000   || 0.304263 | 0.7859 | 0.304263 | 0.7859 || 

Παρατηρούμε ότι τα αποτελέσματα στους 2 αλγόριθμους (6 και 7) είναι παρόμοια, ωστόσο από θέμα διαδοχικών βελτιώσεων,
ο αλγόριθμος 7 είναι καλύτερος κάποιες φορές. Κάποιες φορές βέβαια, ο αλγόριθμος 7 αποτυγχάνει για λίγα σημεία, πχ 10, το 
οποίο οφείλεται το global step όπως είπαμε και προηγουμένως. Και εδώ, ο subdivision δίνει συνήθως μια καλή βελτίωση 
σε σχέση με καποια αρχικοποίηση, αλλά με προσθήκη local και global step κάποιες φορές μπορεί να κάνει επιπλέον βελτίωσεις,
άλλες φορές μπορεί να βελτιώσει ο ένας και ο άλλος να χειροτερεύει το αποτέλεσμα ή και οι 2 να το χειροτερεύσουν διαδοχικά
(πιο σπάνια). Το πλεονεκτημα σε αυτους τους 2 αλγόριθμους σε σχέση με τους 4 και 5 είναι ότι οποιοδήποτε "λάθος" ή χειροτερεύση
του αποτελέσματος γίνει στο 2ο βήμα, υπάρχει μεγάλη πιθανότητα να το βελτιώσει το 3ο βήμα.